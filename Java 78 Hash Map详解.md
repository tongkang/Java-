### Java 7/8 Hash Map详解

#### 一、Java7 HashMap

1、在Java7的时候，HashMap是基于数组和链表实现的

- 核心是基于哈希值的桶和链表
- O(1)的平均查找、插入、删除时间
- 致命缺陷是哈希值的碰撞（collision）

- 经典哈希表的实现：数组+链表

- 默认的初始容量为16，一定是2的幂次方，不是的话就向上取整一个2的幂次方（比如17向上取整一个2次方，为32）。默认负载因子是0.75

  ```java
   static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16，左移四位==2^4=16
  ```

- new一个hashmap是不会初始容量的，只有使用的时候才会初始容量16



##### 1、为什么数组大小一定要是2的幂（对于产生的hashcode值如何放入1~n-1个桶中呢？）

- 首先，我们在获取坐标的的时候，有个方法是`indexFor`，length是数组的大小，2的幂换成二进制是`1000...`，然后按照方法减一，就是`1111...`，再与hashcode做与运算，这样才能快速的拿到数组小标，并且分布还是均匀的

  如果不是2的幂，这样`(length-1)`后，可能是`1011...`，中间是有0的，与任何数做运算都是0，会使得分布不均匀

  ```java
  static int indexFor(int h, int length) {
          // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";
          return h & (length-1);
      }
  ```

  

##### 2、hashMap的扩容

- 容量*负载因子得到的数，就是要扩容的时候。扩容一份新的出来，把原来的数据重新计算到新的表中去，使用的方法是`transfer`
- 最好是开辟合理的初始化大小，因为resize的效率非常低。



##### 3、Java7 hashMap的缺陷

- 非常容易碰到死锁
- 潜在的安全隐患
  - 如果在拼接的参数后面设计一个精心的参数，会使得HashMap变成链表（查找速度为：O(N)）



#### 二、Java 8 HashMap的改进

- 数组+链表/红黑树
- 扩容时插入顺序的改进
- 函数方法
  - forEach
  - compute系列
- Map的新API
  - merge
  - replace

##### 1、为什么hashmap的在链表元素数量超过8时改为红黑树?

因为满足**泊松分布**原则，所以才是8，到八以后的概率非常小



##### 2、为什么为什么要先高16位异或低16位再取模运算?

来降低hash冲突的几率

例如有一些哈希值，低位相同，高位不同。把高16和低16位进行简单的异或（不进位的加法）



##### 3、HashMap的put/get方法

**put（）方法：**

- 没有初始化的时候，执行初始化
- 如果是第一个节点，直接丢一个新的节点
  - 如果是第一个节点，直接覆盖掉
  - 如果是树节点，就放到树节点中
  - 如果是链表，就放到链表中，倘若超过了变数阈值（TREEIFY_THRESHOLD），就进行树的变换



**get（）方法**

- 如果第一个节点是的话，直接返回
- 如果是树，就遍历树
- 如果是链表，就遍历链表



##### 4、HashMap的扩容

- 由于在Java7中，扩容的时候没有保存顺序，就可能成环，
- 现在Java8的扩容就让它保持顺序，但还不是线程安全的，只是降低概率
- 当扩容一倍的容量时，会使当天哈希桶中的链表差分为两部分，高位和低位上