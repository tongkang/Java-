## Java进阶面试题

#### 一、内存布局

##### 1、什么是堆和栈？

- **堆**：所有的对象都放在堆上，会发生GC
- **栈**：里面包括局部变量（Local Variable Array）表和操作数栈（Operand Stack）。上面有个方法栈，只要有方法调用就进栈，运行完就出栈



##### 2、Class存在哪里？

- 方法区中（Method Area）

##### 3、Java7/8之间的内存布局发生了哪些改变？

- Java7：把方法区叫做永久代（PermGen），与堆共享空间
- Java7之后：把方法区额外放在外面，叫meta space（元空间），不会与堆抢占空间，但是会占用物理空间

##### 4、堆里包含哪些区域？

##### 5、栈的结构是什么？

- 栈帧（Frames）：
  - Local Variables（主要）
  - Operand Stacks（主要）
- 当一个方法传入进来一个参数，就是局部变量，当要调用一个新方法，就会涨一个栈帧，这个新方法中就有一个操作数栈，来进行计算，

##### 6、用过哪些Java自带的命令行工具？

- java -version
- java -jar：创建压缩包
- jps -v：查看当前Java的进程有哪些
- javap：反编译字节码
- jhat：查看堆空间
- javac：Java编译
- jstack ：查看当前虚拟机中的栈





#### 二、类加载

##### 1、什么是字节码？

- 字节码与平台无关，Java中通过打jar的方式传入

##### 2、类加载的过程是什么？

- 把一个类的二进制表示加载到虚拟机中，成为虚拟机中一个内部的数据结构表示

比如JVM需要一个类，但是只知道类的名字，不知道具体的内容是什么，就需要从外界加载它。首先请求ClassLoad，它会搜索一个东西叫ClassPath，默认的是按照类的全限定类名去加载

##### 3、什么是类加载器？

- 从一个字节码变成内部表示的过程称为类加载过程（ClassLoading）

##### 4、有几种类加载器？

- bootstrap classLoader  --->(search)    bootstrap classpath
- extension classLoader --->(search)    extension classpath
- application classLoader --->(search)    application classpath

##### 5、什么是双亲委派加载模型？

- 如果你要请求一个类的话，首先会请求顶层最核心的类，找到了就返回，没有就往下找
- 主要是为了安全，避免恶意class

##### 6、instanceof是如何判断是不是同一个实例的？

- 加入JVM中有两个类加载器，从不同的地方加载同一个方法，就会出现问题
- instanceof：不仅会判断**全限定类名**像不像同，还会判断是不是同一个**类加载器**



#### 三、Java的GC

##### 1、什么是GC？为什么要有GC？GC是什么时候发生的？

- GC是垃圾回收，可以自动化帮你回收垃圾
- 内存空间不是无限的，所以需要GC来回收内存空间
- 当new对象的时候，没有空间可以new了，就会触发到GC

##### 2、简单描述一下GC的过程

- new对象--->(内存不够了)  young GC----> majorGC ----> Full GC ---> OOM
- GC有延迟，内存不够了，得等GC结束之后，才能继续new

##### 3、如何判断一个对象是否存活？（哪些对象不是垃圾）

- JVM枚举一组节点（GC roots），定义这些东西不是垃圾。在GC root上所持有的**引用**，所达到的对象(**reachable objects**)都不是垃圾，不可达的就是垃圾。

##### 	GC roots包含哪些东西

- 线程对象

- 栈帧所引用的局部变量
- Class的static field
- native方法引用的对象

##### 4、什么是分代GC？分为哪些代？

- 分代GC：由于大多数的对象在创建的时候，用完就丢，随着时间的推移，最后也有会有一定的对象留下来
- GC分代：
- Young
  - Eden：刚出生的对象
  - Survivor1：当经过一次GC还活着的，就进入这
  - Survivor2：与Survivor1交替进行接收一次GC还活着的对象
- Tenured：经过多次GC还活着的
- Permgen

##### 5、什么是强/弱/软/影子引用？

- 强引用：GC root接触过的引用都是强引用。一定不是垃圾，不要回收
- 弱引用：不会阻止引用的东西被垃圾回收掉
- 软引用：在内存压力比较大的时候来，由GC来决定是否要丢掉
- 影子引用：类似影子一样，标记曾今来过，但是拿不到

##### 6、什么是Stop the world？

- 停止所有活动，等待GC来回收垃圾

##### 7、听说过哪些GC算法？

##### 8、听说过哪些调优参数？

- 场景（例如）：在日志中看到，有大的对象总是提前到Tenured中，这时候就要扩大Young内存空间



#### 四、多线程

##### 1、线程安全是什么

既然在JVM中有多个线程执行，相当于多个人执行同一个方法，但是他们共享同一份区域（Heap，Method Area），堆上的对象被多个线程共享，就会出现线程安全问题。

保证线程安全最直观的多线程和单线程所运行的结果是一样的

例如售票系统来说，会出来的问题就是把一张票卖给了两个人

- Java中如何保证线程安全
  - 使用不可变对象 String/Number/Java8 date API
  - **锁：**保证对资源的排他性访问
  - **无锁容器：**使用CAS进行无锁的线程安全的操作
- 什么是死锁
  - 两个线程的都在等待对方的锁，而僵持不下的状态就是死锁



##### 2、线程池

- 为什么需要使用线程池
  - 线程是个很昂贵的资源，在线程的上下文切换中，非常消耗资源
  - 避免重复的线程来创建线程的额外开销
- 常见线程池和使用场景、参数（参考Executeds和ThreadPoolExecutor）



##### 3、线程的生命周期、状态

参考Thread图和Thread类



##### 4、volatile是干嘛的

- 只保证可见性，不保证安全性
- **CAS**：保证所有的安全性

##### 5、什么是Java线程模型？

##### 6、ThreadLocal的原理？

- 首先ThreadLocal是个对象，在堆上分配。
- 但是每个线程调用`get`方法，却是不同的，是线程自己私有的
- 我们可以把ThreadLocal想成一个Map

##### 7、synchronized和Lock的优缺点？

- synchronized是一个关键字，是Java最初的时候引用的
  - 优点：简单
  - 缺点：没有办法实现公平锁，它的调度非常依赖操作系统。并且一次只有一个线程持有锁，不允许多个线程持有锁
- Lock克服了synchronized的缺点，但是复杂，



##### 8、synchronized的锁升级/锁粗化

- 在jdk1.6之后进行的升级

9、JUC

- **无锁容器的原理CAS**
- 介绍下你知道的JUC工具类
  - CountDownLatch
  - CyclicBarrier
  - Semaphore
  - BlockingQueue



#### 五、数据库/Redis

##### 1、事务和隔离等级

- 事务：
  - 最常见的例子就是银行转账场景，转账期间可能会碰到多个问题，例如ATM断电之类，导致转账不成功，一方转出了钱，另一方没有收到
  - 而事务就是保证事情要不**都发生**，要不**都不发生**
- 事务四大特性（**ACID**）
  - **Atomicity**（原子性）：要不都发生，要不都不发生
  - **Consistency**(一致性)：确保所有数据是一致的
  - **Isolation**(隔离性)：保证交易将独立发生，不会影响其他操作
  - **Durability**(持久性)：一旦提交事务，将会保留在系统中，哪怕系统奔溃
- 隔离等级（效率↑，安全↓）
  - **Read uncommitted** 读未提交，出现问题：**脏读**（看到别人还没提交的数据），效率高，安全低
  - **Read committed** 读已提交，出现问题：**不可重复读**（例如：手机和ATM上同时转账，只有一个能成功）
  - **Repeatable read** 可重复读，出现问题：**幻读**MySQL默认隔离等级
  - **Serializable** 序列化，最严格性能最低 - 悲观锁



##### 2、乐观锁/悲观锁

- 乐观锁：假设做这件事别人没有暂用锁
- 悲观锁：很悲观，每次读写操作都要上一把锁



##### 3、数据库基本数据结构

- B+树



##### 4、索引优化

- 最左匹配
- 如何判断SQL查询是否使用了索引（进行索引优化分析）
  - 对于任何数据库来说，首先进行profiling（性能分析）
    - 对于MySQL来说，查看 **explain**详解



##### 5、如何避免SQL注入？

- MyBatis ORM 使用 #{} ，不要使用 ${}
- JDBC Connection PreparedStatement 不要使用 Statement



##### 6、Redis为什么这么快（10万QPS）

- 全内存操作
- 单线程：避免线程上下文切换的开销



##### 7、Redis支持哪几种数据结构

- String
- List
- Set
- Hash
- Sorted Set（ZSet）
  - 场景：存入经纬度，查找两人之间的距离；投票系统